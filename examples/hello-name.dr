(require std::io)

(defstruct! name [name])

(defenum! option
  (list (Some v) None)
  ; TODO: Add derives
  (:impl (list
     ('is-some
       (lambda (self)
         (match self
           [(Some _) true]
           [(None)   false])))
     ('is-none
       (lambda (self)
         (match self
           [(Some _) false]
           [(None)   true])))
     ('as-list
       (lambda (self)
         (match self
           [(Some x) '(x)]
           [(None)   '()])))
     ('unwrap
       (lambda (self)
         (match self
           [(Some x) x]
           [(None) (panic! "Tried to unwrap None")]))))))

; Roughly generates

(enum option (list (Some v) None))
(defun option/is-some (self)
  (match self
    [(Some _) true]
    [(None)   false]))
(defun option/is-none (self)
  (match self
    [(Some _) false]
    [(None)   true]))
(defun option/unwrap (self)
  (match self
    [(Some x) x]
    [None (panic! "Tried to unwrap None")]))
(defun option/as-list (self)
  (match self
    [(Some x) '(x)]
    [(None)   '()))]

; One way
(let (persons-name (std::io::read-line))
  (if (option/is-some persons-name)
    (let (person (make-name (option/unwrap persons-name)))
      (println! "Hello {}!" (name->name person)))
    (println! "No name given.")))

; Another way
(let (persons-name (std::io::read-line))
  (if-let (Some val) persons-name
    (let (person (make-name val))
      (println "Hello {}!" (name->name person)))
    (println "No name given.")))

; vim:set ft=lisp ts=4 sw=4 et:
