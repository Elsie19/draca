(require std::io)

(defstruct! name [name])

(defenum! option
  (list (Some v) None)
  ; TODO: Add derives
  (:impl (list
     ('is-some
       (lambda (self)
         (match self
           [(Some _) true]
           [(None)   false])))
     ('is-none
       (lambda (self)
         (match self
           [(Some _) false]
           [(None)   true])))
     ('as-list
       (lambda (self)
         (match self
           [(Some x) '(x)]
           [(None)   '()])))
     ('unwrap
       (lambda (self)
         (match self
           [(Some x) x]
           [(None) (panic! "Tried to unwrap None")]))))))

; Roughly generates

(enum option (list (Some v) None))
(defun option/is-some (self)
  (if (option? self)
    (match self
      [(Some _) true]
      [(None)   false])
    (panic! "option/is-some: expected option, got...")))
(defun option/is-none (self)
  (if (option? self)
    (match self
      [(Some _) false]
      [(None)   true])
    (panic! "option/is-none: expected option, got...")))
(defun option/unwrap (self)
  (if (option? self)
    (match self
      [(Some x) x]
      [None (panic! "Tried to unwrap None")])
    (panic! "option/unwrap: expected option, got...")))
(defun option/as-list (self)
  (if (option? self)
    (match self
      [(Some x) '(x)]
      [(None)   '()])
    (panic! "option/as-list: expected option, got...")))

; One way
(let (persons-name (std::io::read-line))
  (if (option/is-some persons-name)
    (let (person (make-name (option/unwrap persons-name)))
      (println! "Hello {}!" (name->name person)))
    (println! "No name given.")))

; Another way
(let (persons-name (std::io::read-line))
  (if-let (Some val) persons-name
    (let (person (make-name val))
      (println "Hello {}!" (name->name person)))
    (println "No name given.")))

; vim:set ft=lisp ts=4 sw=4 et:
